"""
ArtinSmartRealty V2 - The Super Brain
AI Core Logic using Google Gemini 2.0 Flash
Multi-Language Support, Voice Intelligence, Turbo Qualification Flow
"""

import os
import re
import json
import asyncio
from typing import Optional, Dict, Any, List, Tuple
from enum import Enum
from dataclasses import dataclass
import google.generativeai as genai

from database import (
    Lead, Tenant, ConversationState, Language,
    TransactionType, PropertyType, PaymentMethod, Purpose,
    LeadStatus, update_lead, get_available_slots, DayOfWeek
)


# Configure Gemini API
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)


# ==================== LANGUAGE DETECTION & TRANSLATIONS ====================

LANGUAGE_PATTERNS = {
    Language.FA: r'[\u0600-\u06FF]',  # Persian/Arabic script
    Language.AR: r'[\u0600-\u06FF]',  # Arabic script (same range)
    Language.RU: r'[\u0400-\u04FF]',  # Cyrillic script
    Language.EN: r'^[a-zA-Z\s\d\.,!?\'\"-]+$'  # Latin only
}

# Translations dictionary
TRANSLATIONS = {
    "welcome": {
        Language.EN: "ðŸ‘‹ Welcome! I'm {agent_name}'s AI Assistant. How can I help you find your perfect property in Dubai?",
        Language.FA: "ðŸ‘‹ Ø³Ù„Ø§Ù…! Ù…Ù† Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ {agent_name} Ù‡Ø³ØªÙ…. Ú†Ú¯ÙˆÙ†Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ù… Ø¨Ù‡ Ø´Ù…Ø§ Ø¯Ø± ÛŒØ§ÙØªÙ† Ù…Ù„Ú© Ù…Ù†Ø§Ø³Ø¨ Ø¯Ø± Ø¯Ø¨ÛŒ Ú©Ù…Ú© Ú©Ù†Ù…ØŸ",
        Language.AR: "ðŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø£Ù†Ø§ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒÙŠ Ù„Ù€ {agent_name}. ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¹Ù‚Ø§Ø±Ùƒ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠ ÙÙŠ Ø¯Ø¨ÙŠØŸ",
        Language.RU: "ðŸ‘‹ Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ! Ð¯ AI-Ð°ÑÑÐ¸ÑÑ‚ÐµÐ½Ñ‚ {agent_name}. ÐšÐ°Ðº Ñ Ð¼Ð¾Ð³Ñƒ Ð¿Ð¾Ð¼Ð¾Ñ‡ÑŒ Ð²Ð°Ð¼ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¸Ð´ÐµÐ°Ð»ÑŒÐ½ÑƒÑŽ Ð½ÐµÐ´Ð²Ð¸Ð¶Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ð² Ð”ÑƒÐ±Ð°Ðµ?"
    },
    "hook_roi": {
        Language.EN: "ðŸ  Get a FREE ROI Analysis!\n\nSee how much you could earn from Dubai Real Estate investment.\n\nWould you like to receive your personalized report?",
        Language.FA: "ðŸ  ØªØ­Ù„ÛŒÙ„ Ø¨Ø§Ø²Ú¯Ø´Øª Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø±Ø§ÛŒÚ¯Ø§Ù†!\n\nØ¨Ø¨ÛŒÙ†ÛŒØ¯ Ú†Ù‚Ø¯Ø± Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¯Ø± Ø§Ù…Ù„Ø§Ú© Ø¯Ø¨ÛŒ Ø¯Ø±Ø¢Ù…Ø¯ Ú©Ø³Ø¨ Ú©Ù†ÛŒØ¯.\n\nØ¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡ Ø®ÙˆØ¯ Ø±Ø§ Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯ØŸ",
        Language.AR: "ðŸ  Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ØªØ­Ù„ÙŠÙ„ Ø¹Ø§Ø¦Ø¯ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± Ù…Ø¬Ø§Ù†Ù‹Ø§!\n\nØ§ÙƒØªØ´Ù ÙƒÙ… ÙŠÙ…ÙƒÙ†Ùƒ Ø£Ù† ØªÙƒØ³Ø¨ Ù…Ù† Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± Ø§Ù„Ø¹Ù‚Ø§Ø±ÙŠ ÙÙŠ Ø¯Ø¨ÙŠ.\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙ„Ø§Ù… ØªÙ‚Ø±ÙŠØ±Ùƒ Ø§Ù„Ù…Ø®ØµØµØŸ",
        Language.RU: "ðŸ  ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚Ðµ Ð‘Ð•Ð¡ÐŸÐ›ÐÐ¢ÐÐ«Ð™ Ð°Ð½Ð°Ð»Ð¸Ð· ROI!\n\nÐ£Ð·Ð½Ð°Ð¹Ñ‚Ðµ, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð·Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð½Ð° Ð½ÐµÐ´Ð²Ð¸Ð¶Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ð² Ð”ÑƒÐ±Ð°Ðµ.\n\nÐ¥Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚?"
    },
    "phone_request": {
        Language.EN: "ðŸ“± Great! To send you the personalized ROI report, I'll need your phone number.\n\nPlease share your WhatsApp number:",
        Language.FA: "ðŸ“± Ø¹Ø§Ù„ÛŒ! Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ú¯Ø²Ø§Ø±Ø´ ROI Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡ØŒ Ø¨Ù‡ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø´Ù…Ø§ Ù†ÛŒØ§Ø² Ø¯Ø§Ø±Ù….\n\nÙ„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ÙˆØ§ØªØ³Ø§Ù¾ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†ÛŒØ¯:",
        Language.AR: "ðŸ“± Ø±Ø§Ø¦Ø¹! Ù„Ø¥Ø±Ø³Ø§Ù„ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¹Ø§Ø¦Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± Ø§Ù„Ù…Ø®ØµØµ Ù„ÙƒØŒ Ø£Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø±Ù‚Ù… Ù‡Ø§ØªÙÙƒ.\n\nÙŠØ±Ø¬Ù‰ Ù…Ø´Ø§Ø±ÙƒØ© Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:",
        Language.RU: "ðŸ“± ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ð¾! Ð§Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð²Ð°Ð¼ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚ ROI, Ð¼Ð½Ðµ Ð½ÑƒÐ¶ÐµÐ½ Ð²Ð°Ñˆ Ð½Ð¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°.\n\nÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÐµÑÑŒ Ð²Ð°ÑˆÐ¸Ð¼ Ð½Ð¾Ð¼ÐµÑ€Ð¾Ð¼ WhatsApp:"
    },
    "transaction_type": {
        Language.EN: "ðŸ˜ï¸ Are you looking to Buy or Rent?",
        Language.FA: "ðŸ˜ï¸ Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¨Ø®Ø±ÛŒØ¯ ÛŒØ§ Ø§Ø¬Ø§Ø±Ù‡ Ú©Ù†ÛŒØ¯ØŸ",
        Language.AR: "ðŸ˜ï¸ Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ø´Ø±Ø§Ø¡ Ø£Ù… Ø§Ù„Ø¥ÙŠØ¬Ø§Ø±ØŸ",
        Language.RU: "ðŸ˜ï¸ Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÐºÑƒÐ¿Ð¸Ñ‚ÑŒ Ð¸Ð»Ð¸ Ð°Ñ€ÐµÐ½Ð´Ð¾Ð²Ð°Ñ‚ÑŒ?"
    },
    "property_type": {
        Language.EN: "ðŸ¢ What type of property?\n\nâ€¢ Residential (Apartment, Villa)\nâ€¢ Commercial (Office, Retail)",
        Language.FA: "ðŸ¢ Ú†Ù‡ Ù†ÙˆØ¹ Ù…Ù„Ú©ÛŒØŸ\n\nâ€¢ Ù…Ø³Ú©ÙˆÙ†ÛŒ (Ø¢Ù¾Ø§Ø±ØªÙ…Ø§Ù†ØŒ ÙˆÛŒÙ„Ø§)\nâ€¢ ØªØ¬Ø§Ø±ÛŒ (Ø¯ÙØªØ±ØŒ Ù…ØºØ§Ø²Ù‡)",
        Language.AR: "ðŸ¢ Ù…Ø§ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù‚Ø§Ø±ØŸ\n\nâ€¢ Ø³ÙƒÙ†ÙŠ (Ø´Ù‚Ø©ØŒ ÙÙŠÙ„Ø§)\nâ€¢ ØªØ¬Ø§Ø±ÙŠ (Ù…ÙƒØªØ¨ØŒ Ù…ØªØ¬Ø±)",
        Language.RU: "ðŸ¢ ÐšÐ°ÐºÐ¾Ð¹ Ñ‚Ð¸Ð¿ Ð½ÐµÐ´Ð²Ð¸Ð¶Ð¸Ð¼Ð¾ÑÑ‚Ð¸?\n\nâ€¢ Ð–Ð¸Ð»Ð°Ñ (ÐšÐ²Ð°Ñ€Ñ‚Ð¸Ñ€Ð°, Ð’Ð¸Ð»Ð»Ð°)\nâ€¢ ÐšÐ¾Ð¼Ð¼ÐµÑ€Ñ‡ÐµÑÐºÐ°Ñ (ÐžÑ„Ð¸Ñ, ÐœÐ°Ð³Ð°Ð·Ð¸Ð½)"
    },
    "budget": {
        Language.EN: "ðŸ’° What's your budget range?",
        Language.FA: "ðŸ’° Ø¨ÙˆØ¯Ø¬Ù‡ Ø´Ù…Ø§ Ú†Ù‚Ø¯Ø± Ø§Ø³ØªØŸ",
        Language.AR: "ðŸ’° Ù…Ø§ Ù‡ÙŠ Ù…ÙŠØ²Ø§Ù†ÙŠØªÙƒØŸ",
        Language.RU: "ðŸ’° ÐšÐ°ÐºÐ¾Ð² Ð²Ð°Ñˆ Ð±ÑŽÐ´Ð¶ÐµÑ‚?"
    },
    "payment_method": {
        Language.EN: "ðŸ’³ Payment preference?",
        Language.FA: "ðŸ’³ Ø±ÙˆØ´ Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ±Ø¬ÛŒØ­ÛŒØŸ",
        Language.AR: "ðŸ’³ Ù…Ø§ Ù‡ÙŠ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ÙØ¶Ù„Ø©ØŸ",
        Language.RU: "ðŸ’³ ÐŸÑ€ÐµÐ´Ð¿Ð¾Ñ‡Ñ‚Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¾Ð¿Ð»Ð°Ñ‚Ñ‹?"
    },
    "purpose": {
        Language.EN: "ðŸŽ¯ What's the main purpose?\n\nâ€¢ Investment (Rental Income)\nâ€¢ Living (Personal Use)\nâ€¢ Residency (Golden Visa)",
        Language.FA: "ðŸŽ¯ Ù‡Ø¯Ù Ø§ØµÙ„ÛŒ Ú†ÛŒØ³ØªØŸ\n\nâ€¢ Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ (Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ø¬Ø§Ø±Ù‡)\nâ€¢ Ø²Ù†Ø¯Ú¯ÛŒ (Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø®ØµÛŒ)\nâ€¢ Ø§Ù‚Ø§Ù…Øª (ÙˆÛŒØ²Ø§ÛŒ Ø·Ù„Ø§ÛŒÛŒ)",
        Language.AR: "ðŸŽ¯ Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØŸ\n\nâ€¢ Ø§Ø³ØªØ«Ù…Ø§Ø± (Ø¯Ø®Ù„ Ø¥ÙŠØ¬Ø§Ø±ÙŠ)\nâ€¢ Ø³ÙƒÙ† (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø´Ø®ØµÙŠ)\nâ€¢ Ø¥Ù‚Ø§Ù…Ø© (ØªØ£Ø´ÙŠØ±Ø© Ø°Ù‡Ø¨ÙŠØ©)",
        Language.RU: "ðŸŽ¯ ÐšÐ°ÐºÐ¾Ð²Ð° Ð¾ÑÐ½Ð¾Ð²Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ?\n\nâ€¢ Ð˜Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸Ð¸ (Ð”Ð¾Ñ…Ð¾Ð´ Ð¾Ñ‚ Ð°Ñ€ÐµÐ½Ð´Ñ‹)\nâ€¢ ÐŸÑ€Ð¾Ð¶Ð¸Ð²Ð°Ð½Ð¸Ðµ (Ð›Ð¸Ñ‡Ð½Ð¾Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ)\nâ€¢ Ð ÐµÐ·Ð¸Ð´ÐµÐ½Ñ‚ÑÑ‚Ð²Ð¾ (Ð—Ð¾Ð»Ð¾Ñ‚Ð°Ñ Ð’Ð¸Ð·Ð°)"
    },
    "schedule": {
        Language.EN: "ðŸ“… Perfect! Let's schedule a consultation.\n\nHere are available slots:",
        Language.FA: "ðŸ“… Ø¹Ø§Ù„ÛŒ! Ø¨ÛŒØ§ÛŒÛŒØ¯ ÛŒÚ© Ø¬Ù„Ø³Ù‡ Ù…Ø´Ø§ÙˆØ±Ù‡ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒÙ….\n\nØ§ÛŒÙ† Ø²Ù…Ø§Ù†â€ŒÙ‡Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª:",
        Language.AR: "ðŸ“… Ù…Ù…ØªØ§Ø²! Ù„Ù†Ø­Ø¯Ø¯ Ù…ÙˆØ¹Ø¯Ù‹Ø§ Ù„Ù„Ø§Ø³ØªØ´Ø§Ø±Ø©.\n\nØ¥Ù„ÙŠÙƒ Ø§Ù„Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø­Ø©:",
        Language.RU: "ðŸ“… ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ð¾! Ð”Ð°Ð²Ð°Ð¹Ñ‚Ðµ Ð·Ð°Ð¿Ð»Ð°Ð½Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ¾Ð½ÑÑƒÐ»ÑŒÑ‚Ð°Ñ†Ð¸ÑŽ.\n\nÐ’Ð¾Ñ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ ÑÐ»Ð¾Ñ‚Ñ‹:"
    },
    "completed": {
        Language.EN: "âœ… Thank you! Your consultation has been scheduled.\n\nOur agent {agent_name} will contact you at the scheduled time.\n\nSee you soon! ðŸ ",
        Language.FA: "âœ… Ù…ØªØ´Ú©Ø±ÛŒÙ…! Ø¬Ù„Ø³Ù‡ Ù…Ø´Ø§ÙˆØ±Ù‡ Ø´Ù…Ø§ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯.\n\nÙ…Ø´Ø§ÙˆØ± Ù…Ø§ {agent_name} Ø¯Ø± Ø²Ù…Ø§Ù† Ù…Ù‚Ø±Ø± Ø¨Ø§ Ø´Ù…Ø§ ØªÙ…Ø§Ø³ Ø®ÙˆØ§Ù‡Ø¯ Ú¯Ø±ÙØª.\n\nØªØ§ Ø¯ÛŒØ¯Ø§Ø± Ø¨Ø¹Ø¯ÛŒ! ðŸ ",
        Language.AR: "âœ… Ø´ÙƒØ±Ù‹Ø§ Ù„Ùƒ! ØªÙ… Ø¬Ø¯ÙˆÙ„Ø© Ø§Ø³ØªØ´Ø§Ø±ØªÙƒ.\n\nØ³ÙŠØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙˆÙƒÙŠÙ„Ù†Ø§ {agent_name} ÙÙŠ Ø§Ù„Ù…ÙˆØ¹Ø¯ Ø§Ù„Ù…Ø­Ø¯Ø¯.\n\nØ¥Ù„Ù‰ Ø§Ù„Ù„Ù‚Ø§Ø¡! ðŸ ",
        Language.RU: "âœ… Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾! Ð’Ð°ÑˆÐ° ÐºÐ¾Ð½ÑÑƒÐ»ÑŒÑ‚Ð°Ñ†Ð¸Ñ Ð·Ð°Ð¿Ð»Ð°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°.\n\nÐÐ°Ñˆ Ð°Ð³ÐµÐ½Ñ‚ {agent_name} ÑÐ²ÑÐ¶ÐµÑ‚ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð² Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ.\n\nÐ”Ð¾ ÑÐºÐ¾Ñ€Ð¾Ð¹ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð¸! ðŸ "
    },
    "ghost_reminder": {
        Language.EN: "ðŸ‘‹ Hi! I noticed we didn't finish our conversation.\n\nDo you have any questions about Dubai Residency or Real Estate Investment?",
        Language.FA: "ðŸ‘‹ Ø³Ù„Ø§Ù…! Ù…ØªÙˆØ¬Ù‡ Ø´Ø¯Ù… Ú©Ù‡ Ú¯ÙØªÚ¯ÙˆÛŒ Ù…Ø§ ØªÙ…Ø§Ù… Ù†Ø´Ø¯.\n\nØ¢ÛŒØ§ Ø³ÙˆØ§Ù„ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø§Ù‚Ø§Ù…Øª Ø¯Ø¨ÛŒ ÛŒØ§ Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¯Ø± Ø§Ù…Ù„Ø§Ú© Ø¯Ø§Ø±ÛŒØ¯ØŸ",
        Language.AR: "ðŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§! Ù„Ø§Ø­Ø¸Øª Ø£Ù†Ù†Ø§ Ù„Ù… Ù†Ù†Ù‡Ù Ù…Ø­Ø§Ø¯Ø«ØªÙ†Ø§.\n\nÙ‡Ù„ Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ø£Ø³Ø¦Ù„Ø© Ø­ÙˆÙ„ Ø§Ù„Ø¥Ù‚Ø§Ù…Ø© ÙÙŠ Ø¯Ø¨ÙŠ Ø£Ùˆ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø± Ø§Ù„Ø¹Ù‚Ø§Ø±ÙŠØŸ",
        Language.RU: "ðŸ‘‹ ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð·Ð°Ð¼ÐµÑ‚Ð¸Ð», Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ Ð½Ðµ Ð·Ð°ÐºÐ¾Ð½Ñ‡Ð¸Ð»Ð¸ Ð½Ð°Ñˆ Ñ€Ð°Ð·Ð³Ð¾Ð²Ð¾Ñ€.\n\nÐ•ÑÑ‚ÑŒ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹ Ð¾ Ñ€ÐµÐ·Ð¸Ð´ÐµÐ½Ñ‚ÑÑ‚Ð²Ðµ Ð² Ð”ÑƒÐ±Ð°Ðµ Ð¸Ð»Ð¸ Ð¸Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸ÑÑ… Ð² Ð½ÐµÐ´Ð²Ð¸Ð¶Ð¸Ð¼Ð¾ÑÑ‚ÑŒ?"
    },
    "btn_yes": {
        Language.EN: "âœ… Yes",
        Language.FA: "âœ… Ø¨Ù„Ù‡",
        Language.AR: "âœ… Ù†Ø¹Ù…",
        Language.RU: "âœ… Ð”Ð°"
    },
    "btn_no": {
        Language.EN: "âŒ No",
        Language.FA: "âŒ Ø®ÛŒØ±",
        Language.AR: "âŒ Ù„Ø§",
        Language.RU: "âŒ ÐÐµÑ‚"
    },
    "btn_buy": {
        Language.EN: "ðŸ  Buy",
        Language.FA: "ðŸ  Ø®Ø±ÛŒØ¯",
        Language.AR: "ðŸ  Ø´Ø±Ø§Ø¡",
        Language.RU: "ðŸ  ÐšÑƒÐ¿Ð¸Ñ‚ÑŒ"
    },
    "btn_rent": {
        Language.EN: "ðŸ  Rent",
        Language.FA: "ðŸ  Ø§Ø¬Ø§Ø±Ù‡",
        Language.AR: "ðŸ  Ø¥ÙŠØ¬Ø§Ø±",
        Language.RU: "ðŸ  ÐÑ€ÐµÐ½Ð´Ð°"
    },
    "btn_residential": {
        Language.EN: "ðŸ¢ Residential",
        Language.FA: "ðŸ¢ Ù…Ø³Ú©ÙˆÙ†ÛŒ",
        Language.AR: "ðŸ¢ Ø³ÙƒÙ†ÙŠ",
        Language.RU: "ðŸ¢ Ð–Ð¸Ð»Ð°Ñ"
    },
    "btn_commercial": {
        Language.EN: "ðŸ¢ Commercial",
        Language.FA: "ðŸ¢ ØªØ¬Ø§Ø±ÛŒ",
        Language.AR: "ðŸ¢ ØªØ¬Ø§Ø±ÙŠ",
        Language.RU: "ðŸ¢ ÐšÐ¾Ð¼Ð¼ÐµÑ€Ñ‡ÐµÑÐºÐ°Ñ"
    },
    "btn_cash": {
        Language.EN: "ðŸ’µ Cash",
        Language.FA: "ðŸ’µ Ù†Ù‚Ø¯ÛŒ",
        Language.AR: "ðŸ’µ Ù†Ù‚Ø¯Ù‹Ø§",
        Language.RU: "ðŸ’µ ÐÐ°Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ"
    },
    "btn_installment": {
        Language.EN: "ðŸ“Š Installment",
        Language.FA: "ðŸ“Š Ø§Ù‚Ø³Ø§Ø·",
        Language.AR: "ðŸ“Š ØªÙ‚Ø³ÙŠØ·",
        Language.RU: "ðŸ“Š Ð Ð°ÑÑÑ€Ð¾Ñ‡ÐºÐ°"
    },
    "btn_investment": {
        Language.EN: "ðŸ“ˆ Investment",
        Language.FA: "ðŸ“ˆ Ø³Ø±Ù…Ø§ÛŒÙ‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ",
        Language.AR: "ðŸ“ˆ Ø§Ø³ØªØ«Ù…Ø§Ø±",
        Language.RU: "ðŸ“ˆ Ð˜Ð½Ð²ÐµÑÑ‚Ð¸Ñ†Ð¸Ð¸"
    },
    "btn_living": {
        Language.EN: "ðŸ¡ Living",
        Language.FA: "ðŸ¡ Ø²Ù†Ø¯Ú¯ÛŒ",
        Language.AR: "ðŸ¡ Ø³ÙƒÙ†",
        Language.RU: "ðŸ¡ ÐŸÑ€Ð¾Ð¶Ð¸Ð²Ð°Ð½Ð¸Ðµ"
    },
    "btn_residency": {
        Language.EN: "ðŸ›‚ Residency/Visa",
        Language.FA: "ðŸ›‚ Ø§Ù‚Ø§Ù…Øª/ÙˆÛŒØ²Ø§",
        Language.AR: "ðŸ›‚ Ø¥Ù‚Ø§Ù…Ø©/ØªØ£Ø´ÙŠØ±Ø©",
        Language.RU: "ðŸ›‚ Ð ÐµÐ·Ð¸Ð´ÐµÐ½Ñ‚ÑÑ‚Ð²Ð¾/Ð’Ð¸Ð·Ð°"
    }
}

# Budget options in AED
BUDGET_OPTIONS = {
    Language.EN: ["Under 500K AED", "500K - 1M AED", "1M - 2M AED", "2M - 5M AED", "5M+ AED"],
    Language.FA: ["Ø²ÛŒØ± 500 Ù‡Ø²Ø§Ø± Ø¯Ø±Ù‡Ù…", "500 Ù‡Ø²Ø§Ø± ØªØ§ 1 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø¯Ø±Ù‡Ù…", "1 ØªØ§ 2 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø¯Ø±Ù‡Ù…", "2 ØªØ§ 5 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø¯Ø±Ù‡Ù…", "Ø¨Ø§Ù„Ø§ÛŒ 5 Ù…ÛŒÙ„ÛŒÙˆÙ† Ø¯Ø±Ù‡Ù…"],
    Language.AR: ["Ø£Ù‚Ù„ Ù…Ù† 500 Ø£Ù„Ù Ø¯Ø±Ù‡Ù…", "500 Ø£Ù„Ù - 1 Ù…Ù„ÙŠÙˆÙ† Ø¯Ø±Ù‡Ù…", "1 - 2 Ù…Ù„ÙŠÙˆÙ† Ø¯Ø±Ù‡Ù…", "2 - 5 Ù…Ù„ÙŠÙˆÙ† Ø¯Ø±Ù‡Ù…", "Ø£ÙƒØ«Ø± Ù…Ù† 5 Ù…Ù„ÙŠÙˆÙ† Ø¯Ø±Ù‡Ù…"],
    Language.RU: ["Ð”Ð¾ 500 Ñ‚Ñ‹Ñ. AED", "500 Ñ‚Ñ‹Ñ. - 1 Ð¼Ð»Ð½ AED", "1 - 2 Ð¼Ð»Ð½ AED", "2 - 5 Ð¼Ð»Ð½ AED", "5+ Ð¼Ð»Ð½ AED"]
}

BUDGET_RANGES = {
    0: (0, 500000),
    1: (500000, 1000000),
    2: (1000000, 2000000),
    3: (2000000, 5000000),
    4: (5000000, None)
}


# ==================== HELPER CLASSES ====================

@dataclass
class BrainResponse:
    """Response from the Brain to be sent back through the platform."""
    message: str
    buttons: Optional[List[Dict[str, str]]] = None  # [{text, callback_data}]
    next_state: Optional[ConversationState] = None
    lead_updates: Optional[Dict[str, Any]] = None
    should_generate_roi: bool = False
    schedule_slots: Optional[List[Dict]] = None


# ==================== BRAIN CLASS ====================

class Brain:
    """
    The Super Brain - AI Core for ArtinSmartRealty
    Handles all conversation logic, language detection, voice processing,
    and state machine for Turbo Qualification Flow.
    """
    
    def __init__(self, tenant: Tenant):
        self.tenant = tenant
        self.agent_name = tenant.name or "ArtinSmartRealty"
        
        # Initialize Gemini model
        if GEMINI_API_KEY:
            self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
        else:
            self.model = None
    
    def detect_language(self, text: str) -> Language:
        """Auto-detect language from text."""
        if not text:
            return Language.EN
        
        # Check for Persian/Arabic characters
        if re.search(LANGUAGE_PATTERNS[Language.FA], text):
            # Try to distinguish Persian from Arabic using common words
            persian_words = ['Ø§Ø³Øª', 'Ø§ÛŒÙ†', 'Ø¢Ù†', 'Ù…Ù†', 'ØªÙˆ', 'Ù…Ø§', 'Ø´Ù…Ø§', 'Ú†Ù‡', 'Ú©Ù‡']
            arabic_words = ['Ù‡Ø°Ø§', 'Ù‡Ø°Ù‡', 'Ø£Ù†Ø§', 'Ø£Ù†Øª', 'Ù†Ø­Ù†', 'Ù…Ø§', 'Ù„Ø§', 'ÙÙŠ']
            
            persian_count = sum(1 for word in persian_words if word in text)
            arabic_count = sum(1 for word in arabic_words if word in text)
            
            return Language.FA if persian_count >= arabic_count else Language.AR
        
        # Check for Cyrillic (Russian)
        if re.search(LANGUAGE_PATTERNS[Language.RU], text):
            return Language.RU
        
        return Language.EN
    
    def get_text(self, key: str, lang: Language, **kwargs) -> str:
        """Get translated text with variable substitution."""
        text = TRANSLATIONS.get(key, {}).get(lang, TRANSLATIONS.get(key, {}).get(Language.EN, key))
        return text.format(agent_name=self.agent_name, **kwargs)
    
    def get_budget_options(self, lang: Language) -> List[str]:
        """Get budget options in the specified language."""
        return BUDGET_OPTIONS.get(lang, BUDGET_OPTIONS[Language.EN])
    
    async def process_voice(self, audio_data: bytes, file_extension: str = "ogg") -> Tuple[str, Dict[str, Any]]:
        """
        Process voice message using Gemini.
        Returns transcript and extracted entities.
        """
        if not self.model:
            return "", {}
        
        try:
            # Create a prompt for voice transcription and entity extraction
            # Note: Actual audio processing would require additional setup
            # This is a placeholder for the voice processing logic
            
            # For production, you'd use Gemini's multimodal capabilities
            # or a dedicated speech-to-text service
            
            return "", {}
        except Exception as e:
            print(f"Voice processing error: {e}")
            return "", {}
    
    async def extract_entities_from_text(self, text: str, lang: Language) -> Dict[str, Any]:
        """
        Use Gemini to extract real estate entities from text.
        Returns: budget, location, property_type, residency_goal, etc.
        """
        if not self.model or not text:
            return {}
        
        try:
            prompt = f"""
            Analyze this real estate inquiry and extract relevant information.
            Text: "{text}"
            
            Extract the following if mentioned:
            - budget_min: number (in AED)
            - budget_max: number (in AED)
            - location: string (area/neighborhood in Dubai)
            - property_type: "residential" or "commercial"
            - transaction_type: "buy" or "rent"
            - purpose: "investment", "living", or "residency" (Golden Visa)
            - bedrooms: number
            - preferences: list of strings (e.g., "sea view", "high floor")
            
            Return ONLY a valid JSON object with the extracted fields.
            If a field is not mentioned, omit it from the response.
            """
            
            response = await asyncio.to_thread(
                self.model.generate_content,
                prompt
            )
            
            # Parse JSON from response
            response_text = response.text.strip()
            # Try to extract JSON from the response
            json_match = re.search(r'\{[^{}]*\}', response_text, re.DOTALL)
            if json_match:
                return json.loads(json_match.group())
            
            return {}
        except Exception as e:
            print(f"Entity extraction error: {e}")
            return {}
    
    async def generate_ai_response(self, user_message: str, lead: Lead, context: str = "") -> str:
        """
        Generate a contextual AI response using Gemini.
        Used for free-form questions outside the qualification flow.
        """
        if not self.model:
            return self.get_text("welcome", lead.language or Language.EN)
        
        try:
            system_prompt = f"""
            You are {self.agent_name}'s professional AI assistant for Dubai Real Estate.
            
            CRITICAL RULES:
            1. ALWAYS respond in {lead.language.value.upper()} language
            2. Be helpful, professional, and knowledgeable about Dubai real estate
            3. Mention Golden Visa opportunities when relevant (minimum 2M AED investment)
            4. Keep responses concise and actionable
            5. If asked about specific properties, mention that the agent can provide listings
            
            Agent: {self.agent_name}
            Current lead status: {lead.status.value if lead.status else 'new'}
            Budget interest: {lead.budget_min}-{lead.budget_max} {lead.budget_currency or 'AED'}
            Purpose: {lead.purpose.value if lead.purpose else 'not specified'}
            
            Context: {context}
            """
            
            response = await asyncio.to_thread(
                self.model.generate_content,
                [system_prompt, f"User says: {user_message}"]
            )
            
            return response.text.strip()
        except Exception as e:
            print(f"AI response error: {e}")
            return self.get_text("welcome", lead.language or Language.EN)
    
    async def process_message(
        self, 
        lead: Lead, 
        message: str, 
        callback_data: Optional[str] = None
    ) -> BrainResponse:
        """
        Main entry point for processing user messages.
        Implements the Turbo Qualification State Machine.
        """
        lang = lead.language or self.detect_language(message)
        current_state = lead.conversation_state or ConversationState.START
        
        # Update lead language if detected differently
        lead_updates = {"language": lang}
        
        # State Machine Logic
        if current_state == ConversationState.START:
            return self._handle_start(lang)
        
        elif current_state == ConversationState.WELCOME:
            return self._handle_welcome_response(lang, callback_data)
        
        elif current_state == ConversationState.HOOK:
            return self._handle_hook_response(lang, callback_data)
        
        elif current_state == ConversationState.PHONE_GATE:
            return await self._handle_phone_gate(lang, message, lead_updates)
        
        elif current_state == ConversationState.TRANSACTION_TYPE:
            return self._handle_transaction_type(lang, callback_data, lead_updates)
        
        elif current_state == ConversationState.PROPERTY_TYPE:
            return self._handle_property_type(lang, callback_data, lead_updates)
        
        elif current_state == ConversationState.BUDGET:
            return self._handle_budget(lang, callback_data, lead_updates)
        
        elif current_state == ConversationState.PAYMENT_METHOD:
            return self._handle_payment_method(lang, callback_data, lead_updates)
        
        elif current_state == ConversationState.PURPOSE:
            return self._handle_purpose(lang, callback_data, lead_updates)
        
        elif current_state == ConversationState.SCHEDULE:
            return await self._handle_schedule(lang, callback_data, lead)
        
        elif current_state == ConversationState.COMPLETED:
            # For completed leads, use AI for free-form conversation
            ai_response = await self.generate_ai_response(message, lead)
            return BrainResponse(message=ai_response)
        
        # Default: restart flow
        return self._handle_start(lang)
    
    def _handle_start(self, lang: Language) -> BrainResponse:
        """Initial state - send welcome message."""
        return BrainResponse(
            message=self.get_text("welcome", lang),
            next_state=ConversationState.WELCOME,
            buttons=[
                {"text": self.get_text("btn_yes", lang), "callback_data": "start_yes"},
                {"text": self.get_text("btn_no", lang), "callback_data": "start_no"}
            ]
        )
    
    def _handle_welcome_response(self, lang: Language, callback_data: Optional[str]) -> BrainResponse:
        """Handle response to welcome message - proceed to hook."""
        return BrainResponse(
            message=self.get_text("hook_roi", lang),
            next_state=ConversationState.HOOK,
            buttons=[
                {"text": self.get_text("btn_yes", lang), "callback_data": "roi_yes"},
                {"text": self.get_text("btn_no", lang), "callback_data": "roi_no"}
            ]
        )
    
    def _handle_hook_response(self, lang: Language, callback_data: Optional[str]) -> BrainResponse:
        """Handle ROI hook response - proceed to phone gate."""
        if callback_data == "roi_yes":
            return BrainResponse(
                message=self.get_text("phone_request", lang),
                next_state=ConversationState.PHONE_GATE,
                should_generate_roi=True
            )
        else:
            # Skip ROI but still collect phone
            return BrainResponse(
                message=self.get_text("phone_request", lang),
                next_state=ConversationState.PHONE_GATE
            )
    
    async def _handle_phone_gate(self, lang: Language, message: str, lead_updates: Dict) -> BrainResponse:
        """Hard gate - collect phone number."""
        # Extract phone number from message
        phone_pattern = r'[\+]?[(]?[0-9]{1,3}[)]?[-\s\.]?[(]?[0-9]{1,4}[)]?[-\s\.]?[0-9]{1,4}[-\s\.]?[0-9]{1,9}'
        phone_match = re.search(phone_pattern, message)
        
        if phone_match:
            phone = phone_match.group().strip()
            lead_updates["phone"] = phone
            lead_updates["status"] = LeadStatus.CONTACTED
            
            return BrainResponse(
                message=self.get_text("transaction_type", lang),
                next_state=ConversationState.TRANSACTION_TYPE,
                lead_updates=lead_updates,
                buttons=[
                    {"text": self.get_text("btn_buy", lang), "callback_data": "tx_buy"},
                    {"text": self.get_text("btn_rent", lang), "callback_data": "tx_rent"}
                ]
            )
        else:
            # Invalid phone - ask again
            return BrainResponse(
                message=self.get_text("phone_request", lang),
                next_state=ConversationState.PHONE_GATE
            )
    
    def _handle_transaction_type(self, lang: Language, callback_data: Optional[str], lead_updates: Dict) -> BrainResponse:
        """Handle Buy/Rent selection."""
        if callback_data == "tx_buy":
            lead_updates["transaction_type"] = TransactionType.BUY
        else:
            lead_updates["transaction_type"] = TransactionType.RENT
        
        return BrainResponse(
            message=self.get_text("property_type", lang),
            next_state=ConversationState.PROPERTY_TYPE,
            lead_updates=lead_updates,
            buttons=[
                {"text": self.get_text("btn_residential", lang), "callback_data": "prop_res"},
                {"text": self.get_text("btn_commercial", lang), "callback_data": "prop_comm"}
            ]
        )
    
    def _handle_property_type(self, lang: Language, callback_data: Optional[str], lead_updates: Dict) -> BrainResponse:
        """Handle Residential/Commercial selection."""
        if callback_data == "prop_res":
            lead_updates["property_type"] = PropertyType.RESIDENTIAL
        else:
            lead_updates["property_type"] = PropertyType.COMMERCIAL
        
        # Build budget buttons
        budget_options = self.get_budget_options(lang)
        buttons = [{"text": opt, "callback_data": f"budget_{i}"} for i, opt in enumerate(budget_options)]
        
        return BrainResponse(
            message=self.get_text("budget", lang),
            next_state=ConversationState.BUDGET,
            lead_updates=lead_updates,
            buttons=buttons
        )
    
    def _handle_budget(self, lang: Language, callback_data: Optional[str], lead_updates: Dict) -> BrainResponse:
        """Handle budget selection."""
        if callback_data and callback_data.startswith("budget_"):
            budget_idx = int(callback_data.split("_")[1])
            budget_range = BUDGET_RANGES.get(budget_idx, (0, None))
            lead_updates["budget_min"] = budget_range[0]
            lead_updates["budget_max"] = budget_range[1]
        
        return BrainResponse(
            message=self.get_text("payment_method", lang),
            next_state=ConversationState.PAYMENT_METHOD,
            lead_updates=lead_updates,
            buttons=[
                {"text": self.get_text("btn_cash", lang), "callback_data": "pay_cash"},
                {"text": self.get_text("btn_installment", lang), "callback_data": "pay_install"}
            ]
        )
    
    def _handle_payment_method(self, lang: Language, callback_data: Optional[str], lead_updates: Dict) -> BrainResponse:
        """Handle Cash/Installment selection."""
        if callback_data == "pay_cash":
            lead_updates["payment_method"] = PaymentMethod.CASH
        else:
            lead_updates["payment_method"] = PaymentMethod.INSTALLMENT
        
        return BrainResponse(
            message=self.get_text("purpose", lang),
            next_state=ConversationState.PURPOSE,
            lead_updates=lead_updates,
            buttons=[
                {"text": self.get_text("btn_investment", lang), "callback_data": "purp_invest"},
                {"text": self.get_text("btn_living", lang), "callback_data": "purp_living"},
                {"text": self.get_text("btn_residency", lang), "callback_data": "purp_residency"}
            ]
        )
    
    def _handle_purpose(self, lang: Language, callback_data: Optional[str], lead_updates: Dict) -> BrainResponse:
        """Handle purpose selection."""
        if callback_data == "purp_invest":
            lead_updates["purpose"] = Purpose.INVESTMENT
        elif callback_data == "purp_living":
            lead_updates["purpose"] = Purpose.LIVING
        else:
            lead_updates["purpose"] = Purpose.RESIDENCY
        
        lead_updates["status"] = LeadStatus.QUALIFIED
        
        return BrainResponse(
            message=self.get_text("schedule", lang),
            next_state=ConversationState.SCHEDULE,
            lead_updates=lead_updates,
            # Slots will be populated by the caller
            schedule_slots=[]
        )
    
    async def _handle_schedule(self, lang: Language, callback_data: Optional[str], lead: Lead) -> BrainResponse:
        """Handle scheduling selection."""
        if callback_data and callback_data.startswith("slot_"):
            # User selected a slot
            return BrainResponse(
                message=self.get_text("completed", lang),
                next_state=ConversationState.COMPLETED,
                lead_updates={"status": LeadStatus.VIEWING_SCHEDULED}
            )
        
        # Fetch available slots
        slots = await get_available_slots(lead.tenant_id)
        if slots:
            # Format slots for display
            slot_buttons = []
            for slot in slots[:5]:  # Max 5 options
                day = slot.day_of_week.value.capitalize()
                time_str = slot.start_time.strftime("%H:%M")
                slot_buttons.append({
                    "text": f"{day} {time_str}",
                    "callback_data": f"slot_{slot.id}"
                })
            
            return BrainResponse(
                message=self.get_text("schedule", lang),
                next_state=ConversationState.SCHEDULE,
                buttons=slot_buttons
            )
        else:
            # No slots available - complete anyway
            return BrainResponse(
                message=self.get_text("completed", lang),
                next_state=ConversationState.COMPLETED,
                lead_updates={"status": LeadStatus.QUALIFIED}
            )
    
    def get_ghost_reminder(self, lead: Lead) -> BrainResponse:
        """Get ghost protocol reminder message."""
        lang = lead.language or Language.EN
        return BrainResponse(
            message=self.get_text("ghost_reminder", lang),
            buttons=[
                {"text": self.get_text("btn_yes", lang), "callback_data": "ghost_yes"},
                {"text": self.get_text("btn_no", lang), "callback_data": "ghost_no"}
            ]
        )


# ==================== UTILITY FUNCTIONS ====================

async def process_telegram_message(
    tenant: Tenant,
    lead: Lead,
    message_text: str,
    callback_data: Optional[str] = None
) -> BrainResponse:
    """
    Convenience function to process a Telegram message through the Brain.
    """
    brain = Brain(tenant)
    return await brain.process_message(lead, message_text, callback_data)


async def process_voice_message(
    tenant: Tenant,
    lead: Lead,
    audio_data: bytes,
    file_extension: str = "ogg"
) -> Tuple[str, BrainResponse]:
    """
    Process a voice message and return transcript + response.
    """
    brain = Brain(tenant)
    transcript, entities = await brain.process_voice(audio_data, file_extension)
    
    # Update lead with extracted entities if any
    if entities:
        lead_updates = {}
        if "budget_min" in entities:
            lead_updates["budget_min"] = entities["budget_min"]
        if "budget_max" in entities:
            lead_updates["budget_max"] = entities["budget_max"]
        if "property_type" in entities:
            pt = entities["property_type"].lower()
            lead_updates["property_type"] = PropertyType.RESIDENTIAL if pt == "residential" else PropertyType.COMMERCIAL
        if "transaction_type" in entities:
            tt = entities["transaction_type"].lower()
            lead_updates["transaction_type"] = TransactionType.BUY if tt == "buy" else TransactionType.RENT
        if "purpose" in entities:
            p = entities["purpose"].lower()
            if p == "investment":
                lead_updates["purpose"] = Purpose.INVESTMENT
            elif p == "living":
                lead_updates["purpose"] = Purpose.LIVING
            else:
                lead_updates["purpose"] = Purpose.RESIDENCY
        if "preferences" in entities:
            lead_updates["taste_tags"] = entities["preferences"]
        
        if lead_updates:
            await update_lead(lead.id, **lead_updates)
    
    # Process as regular message with transcript
    response = await brain.process_message(lead, transcript or "voice message")
    
    return transcript, response
